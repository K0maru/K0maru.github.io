{"meta":{"title":"不醒人室","subtitle":"","description":"","author":"K0maru","url":"https://K0maru.github.io","root":"/"},"pages":[],"posts":[{"title":"TI第四次作业","slug":"关于51单片机DS18B20和LCD1602的综合运用尝试","date":"2021-10-30T11:25:54.781Z","updated":"2021-10-31T11:05:18.331Z","comments":true,"path":"2021/10/30/关于51单片机DS18B20和LCD1602的综合运用尝试/","link":"","permalink":"https://k0maru.github.io/2021/10/30/%E5%85%B3%E4%BA%8E51%E5%8D%95%E7%89%87%E6%9C%BADS18B20%E5%92%8CLCD1602%E7%9A%84%E7%BB%BC%E5%90%88%E8%BF%90%E7%94%A8%E5%B0%9D%E8%AF%95/","excerpt":"DS18B20&LCD1602","text":"前言本次尝试源自于TI启航班的第四次作业——51单片机使用三个模块解决一个日常生活中的问题，为了装逼我选择了DS18B20和LCD1602来做个温度计，为了凑齐三个模块，我灵光一闪其实是佳利学长给我的启发用独立按键实现了精度的调控，完美完成任务。 DS18B20这是第一次使用这个模块，数据手册翻烂了才知道不匹配，麻了。在网上找到了相关手册完成了设置。 首先是onewire的设置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;STC89C5xRC.H&gt;//onewire.csbit OneWire_DQ=P3^7;unsigned char OneWire_init(void)&#123; unsigned char i; unsigned char AckBit; OneWire_DQ=1; OneWire_DQ=0; Delay500us(); OneWire_DQ=1; i = 32;while (--i);//70us AckBit=OneWire_DQ; Delay500us(); return AckBit;&#125;void OneWire_SendBit(unsigned char Bit)//发送1bit&#123; unsigned char i; OneWire_DQ=0; i = 4;while (--i); OneWire_DQ=Bit; i =24;while (--i); OneWire_DQ=1;&#125;unsigned char OneWire_ReceiveBit(void)//接受1bit&#123; unsigned char Bit; unsigned char i; OneWire_DQ=0; i = 2;while (--i); OneWire_DQ=1; i = 2;while (--i); Bit=OneWire_DQ; i = 24;while (--i); return Bit;&#125;void OneWire_SendByte(unsigned char Byte)//8bit（下同）&#123; unsigned char i; for(i=0;i&lt;8;i++) &#123; OneWire_SendBit(Byte&amp;0x01&lt;&lt;i); &#125;&#125;unsigned char OneWire_ReceiveByte(void)&#123; unsigned char i; unsigned char Byte=0x00; for(i=0;i&lt;8;i++) &#123; if(OneWire_ReceiveBit())&#123;Byte|=0x01&lt;&lt;i;&#125; &#125; return Byte; &#125; 然后是DS18B20的相关设置123456789101112131415161718192021222324#include &lt;STC89C5xRC.H&gt;//DS18B20#include &quot;OneWire.h&quot;void DS18B20_ConverT(void)&#123; OneWire_init(); OneWire_SendByte(0xCC); OneWire_SendByte(0x44);&#125;float DS18B20_ReadT(void)&#123; unsigned char TLSB,TMSB; int Temp; float T; OneWire_init(); OneWire_SendByte(0xCC); OneWire_SendByte(0xBE); TLSB=OneWire_ReceiveByte(); TMSB=OneWire_ReceiveByte(); Temp=(TMSB&lt;&lt;8)|TLSB; T=Temp/16.0; return T;&#125; 接着是LCD1602123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include &lt;STC89C5xRC.H&gt;#include &lt;math.h&gt;#define LCD_DB P0sbit LCD_E=P2^7;sbit LCD_RS=P2^6;sbit LCD_RW=P2^5;void LCD_init(void);void LCD_write_command(unsigned char command);void LCD_write_data(unsigned char dat);void LCD_disp_char(unsigned char x,unsigned char y,unsigned char dat);void LCD_check_busy(void);void delay_n40us(unsigned int n);void LCD_init(void) &#123; LCD_write_command(0x01); LCD_write_command(0x06); LCD_write_command(0x0c); LCD_write_command(0x38); delay_n40us(100);&#125; void LCD_write_command(unsigned char dat) &#123; LCD_DB=dat; LCD_RS=0; LCD_RW=0; LCD_E=1; LCD_E=0; delay_n40us(1);&#125; void LCD_write_data(unsigned char dat) &#123; LCD_DB=dat; LCD_RS=1; LCD_RW=0; LCD_E=1; LCD_E=0; delay_n40us(1); &#125; void LCD_disp_char(unsigned char x,unsigned char y,unsigned char dat) &#123; unsigned char address; if(y==1) address=0x80+x; else address=0xc0+x; LCD_write_command(address); LCD_write_data(dat); &#125; void LCD_check_busy()&#123; do &#123; LCD_E=0; LCD_RS=0; LCD_RW=1; LCD_DB=0xff; LCD_E=1; &#125;while(LCD_DB^7==1); &#125;void delay_n40us(unsigned int n) &#123; unsigned int i; unsigned char j; for(i=n;i&gt;0;i--) for(j=0;j&lt;2;j++);&#125;void LCD__showstring(unsigned char x,unsigned char y,unsigned char *string)&#123; unsigned char i; unsigned char address; if(y==1) address=0x80+x; else address=0xc0+x; LCD_write_command(address); for(i=0;string[i]!=&#x27;\\0&#x27;;i++) &#123; LCD_write_data(string[i]); &#125;&#125;int LCD_pow(int x,int y)&#123; unsigned char i; int result=1; for(i=0;i&lt;y;i++) &#123; result*=x; &#125; return result;&#125;void LCD_shownum(unsigned char x,unsigned char y,unsigned int num,unsigned char length)&#123; unsigned char i; unsigned char address; if(y==1) address=0x80+x; else address=0xc0+x; LCD_write_command(address); for(i=length;i&gt;0;i--) &#123; LCD_write_data(0x30+num/LCD_pow(10,i-1)%10); &#125;&#125;void LCD_showsignednum(unsigned char x,unsigned char y,int num,unsigned char length)&#123; unsigned char i; unsigned char address; unsigned int num1; if(y==1) address=0x80+x; else address=0xc0+x; LCD_write_command(address); if(num&gt;+0) &#123; LCD_write_data(&#x27;+&#x27;); num1=num; &#125; else &#123; LCD_write_data(&#x27;-&#x27;); num1=-num; &#125; for(i=length;i&gt;0;i--) &#123; LCD_write_data(0x30+num1/LCD_pow(10,i-1)%10); &#125;&#125;void LCD_showHexnum(unsigned char x,unsigned char y,unsigned int num,unsigned char length)&#123; unsigned char i; unsigned char address; unsigned char singlenum; if(y==1) address=0x80+x; else address=0xc0+x; LCD_write_command(address); for(i=length;i&gt;0;i--) &#123; singlenum=num/LCD_pow(16,i-1)%16; if(singlenum&lt;10) &#123; LCD_write_data(&#x27;0&#x27;+singlenum); &#125; else &#123; LCD_write_data(&#x27;A&#x27;+singlenum-10); &#125; &#125; &#125;void LCD_showBinnum(unsigned char x,unsigned char y,unsigned int num,unsigned char length)&#123; unsigned char i; unsigned char address; unsigned char singlenum; if(y==1) address=0x80+x; else address=0xc0+x; LCD_write_command(address); singlenum=num/LCD_pow(2,i-1)%2; LCD_write_data(&#x27;0&#x27;+singlenum);&#125; 至于主函数则非常简单1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;STC89C5xRC.H&gt;#include &lt;math.h&gt;#include &quot;DS18B20.h&quot;#include &quot;LCD1602.h&quot;sbit Key1=P2^1;//我之前忘记给按键整模块化了！！！！sbit Key2=P2^0;float T;void Delay30ms() //@12.000MHz&#123; unsigned char i, j; i = 59; j = 90; do &#123; while (--j); &#125; while (--i);&#125;void main()&#123; unsigned char length; unsigned int ten; length=4; LCD_init(); LCD__showstring(0,1,&quot;TEMP:&quot;); while(1) &#123; DS18B20_ConverT(); T=DS18B20_ReadT(); if(Key1==0&amp;&amp;length&lt;4) &#123; Delay30ms(); if(Key1==0) &#123; Delay30ms(); length++; LCD_init(); LCD__showstring(0,1,&quot;TEMP:&quot;); &#125; &#125; if(Key2==0&amp;&amp;length&gt;0) &#123; Delay30ms(); if(Key2==0) &#123; Delay30ms(); length--; LCD_init(); LCD__showstring(0,1,&quot;TEMP:&quot;); &#125; &#125; ten=pow(10,length); if(T&lt;0) &#123; LCD_disp_char(0,2,&#x27;-&#x27;); T=-T; &#125; else &#123; LCD_disp_char(0,2,&#x27;+&#x27;); &#125; LCD_shownum(1,2,T,3); LCD_disp_char(4,2,&#x27;.&#x27;); LCD_shownum(5,2,(unsigned long)(T*ten)%ten,length); &#125;&#125; 实验效果初始显示+025.0000测试发现敏感度还可以图等会放 总结没有。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-10-30T10:42:07.707Z","updated":"2021-10-30T10:42:07.707Z","comments":true,"path":"2021/10/30/hello-world/","link":"","permalink":"https://k0maru.github.io/2021/10/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}